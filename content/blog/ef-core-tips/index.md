---
title: "EF Core Improvements"
date: "2020-08-04 00:00:00Z"
---

## Overview

I have been using Entity Framework Core 3.1 on a .Net Core 3.1 API recently for work.
Along the way, we have learned from others and found a few improvements to make life easier,
make the code more readable and increase performance. None of these are novel concepts,
but they are all things that have had a significant impact on the way we code for the API.

## Projection Expressions

First of all, credit where credit is due, this practice came from a co-worker who shared
a link to the blog [Expression and Projection Magic for Entity Framework Core](https://benjii.me/2018/01/expression-projection-magic-entity-framework-core/).
Ben Cull covers it much more in-depth than I will here so, if you are interested in actually
implementing this, I would read through his post.

Querying a relational database of any size comes with balancing performance and readability.
When creating Data Transfer Objects (DTOs) for an entity, you often don't need every column of
the table that represents that entity, or you need to join in data from other tables.
Entity framework is able to handle the joins and only querying the columns you need through
a 'Select' method on an IQueryable.

In the code below, we have a class representing the entity in the database and a controller action.
The controller action queries the database to get the list of entities and returns a subset
of the data that is needed.

```csharp
namespace Example.Models
{
    [Table("Bill")]
    public class Bill : Entity
    {
        [Required]
        [StringLength(100)]
        public String BillNumber { get; set; }

        [StringLength(200)]
        public String Description { get; set; }

        [Required]
        public DateTime StartDate { get; set; }

        [Required]
        public DateTime EndDate { get; set; }
    }
}}
```

```csharp
namespace Example.Controllers
{
    [ApiController]
    [Produces("application/json")]
    public class BillController : BaseApiController
    {
        [HttpGet]
        [Route("/api/v1/Bills")]
        public async Task<ActionResult<IEnumerable<ApiBillRead>>> GetBills(
            [FromQuery(Name = "startDate")] DateTime? startDate = null,
            [FromQuery(Name = "endDate")] DateTime? endDate = null,
            [FromQuery(Name = "billNumber")] string billNumber = null)
        {
            using var context = await _provider.NewDbContextAsync()

            var bills = context.Bill.Where(x => !x.IsDeleted);

            // Dates
            // This gathers all bills that intersect the date range
            if (startDate.HasValue)
            {
                bills = bills.Where(x => x.EndDate.Date >= startDate.Value.Date);
            }
            if (endDate.HasValue)
            {
                bills = bills.Where(x => x.StartDate.Date <= endDate.Value.Date);
            }

            // Bill Number
            if (!string.IsNullOrEmpty(billNumber))
            {
                bills = bills.Where(x => string.Equals(billNumber, x.BillNumber));
            }

            return bills
                .Select(bill => new {
                    Id = bill.Id,
                    Number = bill.BillNumber,
                    Description = bill.Description
                })
                .ToList();
        }
    }
}
```

The query that is generated by this command, if no parameters are passed, is below.
You will notice that the 'StartDate' and 'EndDate' are not even included in the query
and would not be returned by the database.

```sql
SELECT [Id], [BillNumber], [Description]
FROM Bill
```

This code will return a DTO in JSON as below:

```json
[
  {
    "Id": "f832695e-82ba-4004-9a19-6d750f3566fa",
    "Number": "001",
    "Description": "First Bill"
  },
  {
    "Id": "9aa5f23d-bdc7-4bad-9d17-dcf5deaea8db",
    "Number": "002",
    "Description": "Second Bill"
  }
]
```

The secret to trimmed down queries is the 'Select' method. By using the 'Select' we are
able to only list the properties we actually want from the database.

The approach above uses an anonymous object as a response.
For documentation and reusability, most APIs prefer to add a DTO class such as the one below.

```csharp
namespace Example.Controllers.Models.Bill
{
    public class ApiBillRead
    {
        [JsonPropertyName("id")]
        public Guid Id { get; }

        [JsonPropertyName("billNumber")]
        public string BillNumber { get; }

        [JsonPropertyName("description")]
        public string Description { get; }

        public ApiBillRead(Guid id, string billNumber, string description)
        {
            Id = id;
            BillNumber = billNumber;
            Description = description;
        }
    }
}
```

This means we can change our controller action to be the following:

```csharp
...

return bills
    .Select(bill =>
        new ApiBillRead(
            bill.Id,
            bill.BillNumber,
            bill.Description))
    .ToList();

...
```

This is now a reusable class that can be documented using Swagger or anything else.
However, any time I need to return this DTO, I have to instantiate from it's properties.
That is fine for this very small DTO with 3 properties, but quickly becomes unmanageable.
For maximum reusability, I will modify the DTO to be the following.

```csharp
namespace Example.Controllers.Models.Bill
{
    public class ApiBillRead
    {
        [JsonPropertyName("id")]
        public Guid Id { get; }

        [JsonPropertyName("billNumber")]
        public string BillNumber { get; }

        [JsonPropertyName("description")]
        public string Description { get; }

        public ApiBillRead(Guid id, string billNumber, string description)
        {
            Id = id;
            BillNumber = billNumber;
            Description = description;
        }

        public static Expression<Func<Bill, ApiBillRead>> Projection =>
            bill =>
                new ApiBillRead(
                    bill.Id,
                    bill.BillNumber,
                    bill.Description);
    }
}
```

I can then modify the controller again to use the 'Projection' method I created.
You will notice that the 'Projection' does not look much different from when the DTO is
instantiated inline, but now the mapping is stored on the DTO and we still only query
for the properties we need.

```csharp
...

return bills
    .Select(ApiBillRead.Projection)
    .ToList();

...
```

Joining data from other tables is done in the same way as accessing any other properties. Since
the query is receiving every field you need, when it builds the query it will create any joins
necessary to make sure all the properties are filled. See below for an expanded example of 
the 'ApiBillRead' class with Vendor info coming from a child table of 'Bill';

```csharp
namespace Example.Controllers.Models.Bill
{
    public class ApiBillRead
    {
        [JsonPropertyName("id")]
        public Guid Id { get; }

        [JsonPropertyName("billNumber")]
        public string BillNumber { get; }

        [JsonPropertyName("description")]
        public string Description { get; }

        [JsonPropertyName("vendorId")]
        public Guid? VendorID { get; }

        [JsonPropertyName("vendorName")]
        public string VendorName { get; }

        public ApiBillRead(Guid id, string billNumber, string description,
            Guid? vendorId, string vendorName)
        {
            Id = id;
            BillNumber = billNumber;
            Description = description;
            VendorID = vendorId;
            VendorName = vendorName;
        }

        public static Expression<Func<Bill, ApiBillRead>> Projection =>
            source =>
                new ApiBillRead(
                    source.Id,
                    source.BillNumber,
                    source.Description,
                    source.VendorID,
                    source.Vendor.Name);
    }
}
```

## IQueryable Extensions

## Breaking up Queries and using Lookups
